08/05/25 - setup
#backend
- con docker aperto, dal cmd aperto nella cartella backend, lanciare  docker build -t anonimadata-backend . per costruire l'immagine docker (si basa su Dockerfile)
- per lanciare l'immagine eseguire docker run -it -p 8080:8080 anonimadata-backend
- collegarsi a localhost:8080 per vedere messaggio di ok

#terraform
- variables.tf contiene le variabili cos√¨ sono parametrizzate
- cloudrun.tf contiene il codice per cloudrun su GCP
- main.tf contiene le info sul provider e su terraform

per eseguire il codice, da dentro la cartella:
    terraform init
    terraform plan -var="project_id=IL_TUO_PROJECT_ID"
    terraform apply -var="project_id=IL_TUO_PROJECT_ID"

Come usare Firebase Authentication in un progetto GCP
üîπ 1. Attiva Firebase sul tuo progetto GCP
        - Vai su: https://console.firebase.google.com
        - Clicca su ‚ÄúAggiungi progetto‚Äù
        - Seleziona il tuo progetto GCP esistente
        - Attiva Firebase Authentication
üîπ 2. Abilita il provider di accesso (Google, email, ecc.)
        - Nella Firebase Console: Authentication ‚Üí Sign-in method
        - Abilita Google
        - Inserisci il tuo dominio e URI di reindirizzamento, se richiesto
        - (Facoltativo: anche email/password, GitHub, ecc.)
Per runnare il container serve il file .json prodotto da firebase dopo averlo attivato su GCP, quindi:
    1- Scarica il file .json della service account da Firebase
    2- Rinominalo in firebase-service-account.json e mettilo nella stessa cartella backend
    3- Esegui con Docker o deploya su Cloud Run

Perch√® abbiamo scelto Firebase e non Identity Platform? perch√® prevediamo solo login con google, fino a una certa soglia Firebase √® grautito mentre IP si paga sempre, non ci serve MFA o login aziendali

Riassunto del giorno: scritto codice di terraform e backend compreso di autenticazione tramite firebase. Non ho testato/eseguito NIENTE. Non ho toccato GCP (quindi non ho nemmeno attivato Firebase). Manca tutta la parte frontend (i file sono mockup vuoti)

TODO: eseguire le robe, aggiungere firebase su GCP, scrivere frontend

08/05/2025 - Setup
#Frontend
Setup
1. Installa Node.js    https://nodejs.org/
    (Facoltativo) Possibilt√† di installare choco, un gestore di pacchetti per Windows, ti permette di installare programmi direttamente da terminale 
2. Verifica installazione: node -v     e    npm -v   
3. nstalla Vite CLI: npm install -g create-vite
4. Crea progetto Vite React: npm create vite@latest frontend -- --template react
4. Progetto react
5. Creo nuova cartella "S_R" in locale.Dentro la nuova cartella: cd frontend    npm install   
6. Avvia server: npm run dev
7. Apri Chrome e vai su http://localhost:5173/ per vedere l'app React
       
Visual studio code
Apro la cartella "S_R" su VSCode e inizio a modificare il file  frontend/src/App.jsx
Dentro src/, creo una nuova cartella chiamata components con due file:
    - UploadForm.jsx ‚Üí gestisce il caricamento del file
    - AlgorithmSelector.jsx ‚Üí mostra la selezione dell‚Äôalgoritmo 
    - styles.css -> aggiunge stili al progetto

PER APRIRE IL SITO WEB
1. Entrare nella cartella frontend
2. Aprire terminale git bash
3. Lanciare il comando     npm run dev
4. Copiare sul web il link che viene generato 
5. Chiudendo il terminale si chiude anche il sito web


17/05/2025 - Frontend

Ho essenzialmente rifatto totalmente il frontend. Situazione attuale:

COMPOSIZIONE PROGETTO

frontend/
‚îú‚îÄ‚îÄ node_modules/              # Dipendenze del progetto (generate automaticamente)
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ index.html             # HTML base dell'app React, punto di mount della SPA
‚îú‚îÄ‚îÄ src/                       # Cartella principale del codice sorgente
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ assets/                # Immagini e risorse statiche
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ banner-bg.jpg      # Immagine di sfondo usata nell'homepage e nel login
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ components/            # Componenti React riutilizzabili
‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AlgorithmSelector.jsx     # Dropdown per selezionare l‚Äôalgoritmo di anonimizzazione
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ FileUpload.jsx            # Componente per caricare un file (dataset)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HomePage.jsx              # Pagina principale dopo il login, contiene upload e algoritmi
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginPage.jsx             # Pagina di login con input email/password
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WhiteBox.jsx              # Box stilizzato usato come contenitore
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ styles/                # File CSS di stile per i componenti
‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.css            # Stili globali dell'app (layout, header, titolo, etc.)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ButtonUpload.css   # Stili specifici per il bottone di upload file
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Login.css          # Stili specifici della pagina di login
‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ App.test.js            # File di test per l'app (React Testing Library o Jest)
‚îÇ   ‚îú‚îÄ‚îÄ MainApp.jsx            # Entry point della SPA, include routing tra Login e Home
‚îÇ   ‚îú‚îÄ‚îÄ reportWebVitals.js     # (Opzionale) per monitorare performance dell'app React
‚îÇ   ‚îú‚îÄ‚îÄ setupTests.js          # Configurazione per i test automatici
‚îÇ   ‚îî‚îÄ‚îÄ logo.svg               # Logo React di default (probabilmente inutilizzato)
‚îÇ
‚îú‚îÄ‚îÄ .gitignore                 # File per ignorare cartelle (es. node_modules) in Git
‚îú‚îÄ‚îÄ Dockerfile                 # File per creare un'immagine Docker dell'app
‚îú‚îÄ‚îÄ eslint.config.js           # Configurazione per linting del codice
‚îú‚îÄ‚îÄ index.html                 # File HTML base (doppione nella root: da verificare)
‚îú‚îÄ‚îÄ package-lock.json          # Mappa delle dipendenze (versioni esatte)
‚îú‚îÄ‚îÄ package.json               # Metadata del progetto e lista dipendenze


COSA FA ATTUALMENTE IL FRONTEND
Il frontend √® un'applicazione React con routing di base e componenti modulari. Attualmente include:

1. LoginPage.jsx
Form di login utente (non ancora collegato a un sistema di autenticazione reale)

2. HomePage.jsx
Pagina principale dopo il login
	- Solo esetico: Caricare un dataset
	- Solo esetico: Scegliere un algoritmo
	- Bottone Anonymize abilitato solo se file e algoritmo sono selezionati

21/05/25 - backend
- ho creato una nuova cartella di backend per cercare di uniformare il lavoro e dividere bene in moduli 
- ho modificato la parte di chiamata del backend nel frontend. Non ho eliminato ancora la parte vecchia visto che non sono sicura sia corretta la nuova parte
- ho dovuto installare npm install react-router-dom, ricordiamocelo per una futura guida di come far partire il progetto da dare al prof

22/05/25 - collegamento backend e frontend
- eliminata cartella vecchia di backend
- adesso il backend e il frontend si parlano correttamente
- nella cartella utility ho messo un file .csv per testare il funzionamento
- WORKFLOW per far funzionare tutto: 
    1- aprire dokcer desktop
    2- da una prima finestra w1 nel backend (w1/backend) lanciare docker run -it -p 8080:8080 anonimadata-backend
    3- (w2/frontend) lanciare npm run dev e aprire browser

TO DO:
- sistemare estetica bottone "upload dataset" perch√® √® brutto (anche se funziona)
- [frontend] gli algoritmi l-diversity e t-closeness che non hanno parametro non abilitano tasto anonymize
- implementare effettivamente i vari metodi di anonimizzazione
- csv funziona correttamente, c'√® da testare con file json

23/05/2025 - frontend
- Bottone upload dataset sistemato

23/05/25 - docker frontend
- implementato con successo docker per il frontend
- testato anche con file .json e funziona correttamente, inoltre non permette di selezionare altri tipi di file come da traccia
- anche il file di test .json √® presente nella cartella utility
- prima di avviare il container la prima volta bisogna costruirlo con  docker build -t anonimadata-frontend . (nella cartella del frontend)
- WORKFLOW per far funzionare tutto: 
    1- aprire docker desktop
    2- da una prima finestra w1 nel backend (w1/backend) lanciare docker run -it -p 8080:8080 anonimadata-backend
    3- (w2/frontend) lanciare docker run -p 8081:80 anonimadata-frontend e aprire browser con indirizzo localhost:8081

TO DO:
- [frontend] gli algoritmi l-diversity e t-closeness che non hanno parametro non abilitano tasto anonymize
- implementare effettivamente i vari metodi di anonimizzazione

24/05/25 - k_anon
- scritto algoritmo di k_anon, ma lo devo aggiustare visto che non fa bene il suo lavoro

25/05/2025  differential privacy
- scritto algoritmo differential privacy ma andrebbe controllato bene
- sistemato preview dati frontend

DA FARE PRIMA DI TUTTO
- Rebuildare backend -> Ho aggiunto la libreria diffprivlib

30/05/25 - l_div
- scritto algoritmo di l_div, ma va testato meglio e migliorato
- ho aggiunto anche la comparsa del parametro nel frontend che non c'era per l_div

31/05/25
1. Ho notato che non faceva gli aggiornamenti in tempo reale nel frontend salvando il file su vs code, quindi ho fatto delle modifiche:
    - ./frontend/Dockerfile 	modificato	// build produzione
    - ./backend/Dockerfile 		modificato	
    - ./frontend/vite.config.js 	modificato	
    - ./frontend/Dockerfile.dev	creato 		// per orchestrare frontend e backend
    - gruppo-5/docker-compose.yml	creato		// dev server con hot reload, permette modifica realtime
Adesso per far buildare i server non serve fare il doppio passaggio di prima, perch√© vengono buildati e runnati ogni volta in automatico. Devi:
    - Aprire una bash in gruppo-5, quindi nella root della cartella e lanciare docker-compose up --build
    Fine. Fammi sapere se non ti va bene
2. Ho modificato anche lo scroll verticale, bloccandolo ed evitando che scorra all'infinito (modifiche ad App.css)
3. Ho scritto l'algoritmo di t-closeness ma non funziona, da rivedere

06/06/25 - l_div e anonymize
- aggiunti file per le gerarchie delle generalizzazioni e identificazione dinamica degli attributi sensibili/quasi id/identificativi
- l_div funzionante. non penso ci rimetter√≤ le mani

08/06/25 - diff priv
- Scritto algoritmo differential privacy, abbastanza soddisfatta.

13/06/25
- integrato con successo k_anon con hierarchy_builders
- quindi al momento sia k-anon che l-div vanno con una generalizzazione molto semplice, ma funzionale

14/06/25 - t-close
- Realizzato codice t-close, funziona abbastanza bene. Da capire se trattare solo le colonne numeriche √® giusto.
- A questo punto differential privacy e t-closeness sono accettabili.
- Modifiche:
	- private.txt: aggiornamento modifiche
	- t-closeness: algoritmo terminato
	- anonymize.py: Aggiunte alcune righe per creazione cartella in cui salvare il file, creazione della parte di download dataset anonimizzato
	- Homepage.jsx: Aggiunte alcune righe per download del file e creazione pulsante di download dataset completo
- A questo punto quando clicchiamo sul bottone "anonymize" e scarica il dataset lato server. Quando premiamo su "download full dataset" scarica il file lato client nella cartella download

14/06/25 - terraform files
- ho scritto i file terraform che dovrebbero servirci (spoiler no)

16/06/25 - setu GCP (che Dio ci aiuti)
- numero progetto: 583549727222 ID PROGETTO: gruppo-5
- per sicurezza in caso di danni, mi segno tutti i comandi lanciati
    1- gcloud auth login
    2- attivate api {
        gcloud services enable \
        compute.googleapis.com \
        run.googleapis.com \
        iam.googleapis.com \
        cloudresourcemanager.googleapis.com \
        firestore.googleapis.com \
        storage.googleapis.com \
        iamcredentials.googleapis.com \
        firebase.googleapis.com \
        cloudbuild.googleapis.com
    }
    3- creato bucket GCS per terraform per salvare lo stato condiviso di terraform [comando: gsutil mb -p gruppo-5 -l europe-west1 gs://tfstate-anonimadata/]
    4- lanciato terraform init dalla cartella terraform (probabilmente questo comando lo devi lanciare pure tu Dani), se d√† errore di auth lanciare gcloud auth application-default login
    5- deploy del frontend (Cloud CDN + HTTPS Load Balancer)
        - caricati file statici nel bucket GCS con  gsutil cp -r dist/* gs://anonimadata-frontend-bucket/
        - adesso c'√® un ip pubblico associato al load balancer, il frontend servito da GCS per evitare pubblico allUsers, CDN abilitato per caching e velocit√†
        - per ora c'√® solo connessione http (porta 80), se vogliamo https ci sono configurazioni extra
        - lanciato gsutil -m rsync -r ./dist gs://anonimadata-frontend-bucket
        - il frontend dovrebbe essere accessibile da http://storage.googleapis.com/anon-frontend-bucket/index.html ma da' problemi di auth
        - ABBANDONATO BUCKET GCS E DEPLOYATO ANCHE IL FRONTEND SU CLOUDRUN
        - ‚ÄúPer motivi di rapidit√† e semplicit√†, e dato che la traccia richiede solo la dimostrazione di scalabilit√† e affidabilit√† su GCP, abbiamo utilizzato l‚ÄôURL HTTPS predefinito fornito da Cloud Run. Questo URL supporta gi√† HTTPS e OAuth 2.0 in modo sicuro, evitando cos√¨ la complessit√† e i rischi di gestione di un dominio personalizzato, pur garantendo una piattaforma scalabile, affidabile e sicura.‚Äù

17/06/25 - deploy cloudrun
- lanciato $ gcloud services enable artifactregistry.googleapis.com
- lanciato gcloud artifacts repositories create anonimadata-repo \
  --repository-format=docker \
  --location=europe-west1 \
  --description="Repo immagini Docker per anonimadata"
- taggato e pushato il backend e il frontend :docker tag anonimadata-backend europe-west1-docker.pkg.dev/gruppo-5/anonimadata-repo/backend
 e docker push europe-west1-docker.pkg.dev/gruppo-5/anonimadata-repo/backend
- fatto il deploy solo del backend lanciando gcloud run deploy backend-service \
  --image europe-west1-docker.pkg.dev/gruppo-5/anonimadata-repo/backend \
  --region europe-west1 \
  --platform managed \
  --allow-unauthenticated
  - mi dava warning su autorizzazione, perci√≤ per ora siamo autorizzate solo io e te dani

  - riassunto:
    1- Sistemato Dockerfile del frontend (porta 8080, config nginx).
    2- üì¶ Costruita l'immagine Docker localmente.
    3- üê≥ Push delle immagini su Artifact Registry.
    4- ‚òÅÔ∏è Deploy del backend completato e testato.
    5- üß™ Verificato che il backend funzioni, almeno in modalit√† temporaneamente pubblica
- ho fatto la stessa identica cosa sul frontend e con il curl + token va, solo che senza login non possiamo accedere al sito
- ho provato a sistemare terraform (visto che ho usato solo la riga di comando), ma mi da problemi di autenticazione, risolvo domani

18/06/25 - sistemato terraform
- Sono state definite risorse Terraform per i servizi Cloud Run di backend e frontend, specificando nome, regione, immagine container e porta di ascolto (8080 per backend, 80 per frontend).
- Per i permessi, sono stati configurati i binding IAM roles/run.invoker per consentire a specifici utenti Google di invocare i servizi, garantendo sicurezza e accesso controllato. (poi da cambiare quando avremo auth)
- √à stato commentato lo stato remoto tramite bucket GCS (in precedenza configurato, opzionale a seconda del progetto).
- Risorse Cloud Run gi√† esistenti (create manualmente via CLI o console) sono state importate nello stato Terraform tramite il comando terraform import, allineando cos√¨ lo stato locale con l‚Äôinfrastruttura reale.
- Applicati aggiornamenti per sincronizzare le immagini dei container con le ultime versioni presenti nel repository, tramite terraform apply.


18/06/25 - implementato con successo login firebase
- adesso il login funziona
- DANI devi creare un file .env nella cartella gruppo-5 e un file .env nella cartella frontend con ci√≤ che ti dir√≤ poi
- bisogna proteggere la pagina localhost:8081/home perch√® √® direttamente accessibile (ora mi ci metto)
- va aggiustata la grafica del login magari perch√® ho commentato tutta la pagina vecchia e non ho badato all'estetica

18/06/25 - sistemato /home
- adesso non √® pi√π accessibile senza autenticazione
- reso funzionante anche il tasto di logout
- per adesso se l‚Äôutente fa login, poi chiude il browser senza fare logout, al riavvio sar√† ancora autenticato. La sessione dura praticamente fino a logout esplicito, revoca lato server, o cancellazione dati browser. Se si vuole che la sessione duri solo finch√© la scheda √® aperta, devi cambiare la persistenza a session [da capire se abbiamo tempo/voglia/dobbiamo farlo per forza]

20/06/25 - cloud run, firebase e problemi corse
- in locale funziona ancora tutto benissimo, il problema √® quando si vuole usare GCP perch√® il fatto che sia il frontend che il backend non siano pubblicamente accessibili, impedisce il normale funzionamento anche se il codice √® corretto
- ho provato varie strategie, tra cui anche cloud endpoint, ma non √® cambiato nulla
- per accedere da browser al frontend con GCP per ora bisogna usare proxy gcloud col comando  gcloud run services proxy frontend-service --project gruppo-5 --region europe-west1
- tramite curl il frontend funziona cos√¨ curl -H "Authorization: Bearer $(gcloud auth print-identity-token)" https://frontend-service-583549727222.europe-west1.run.app/
- il backend invece cos√¨  curl -X POST "https://backend-service-hclc243hba-ew.a.run.app/anonymize"   -H "Authorization: Bearer eyJhbGciO...[insomma tutto il token firebase]"   -F "file=@/c/Users/valen/OneDrive/Desktop/gruppo-5/utility/AgeGenderZipCodeDisease.csv"   -F "algorithm=k-anonymity"   -F "parameter=3"
- token firebase =/= identity tokendi gcp 
- ho scritto i codici deploy-frontend.sh e deploy-backend.sh da lancaire direttamente nella root per eseguire in maniera automatica aggiornamento dell'immagine, con relativo push su cloud run e anche apply su terraform
- sinceramente non so come risolvere il non poter settare come allUsers l'autenticazione del frontend e del backend

21/06/25 - firestore
- ho implementato il firestore, solo che non ho modo di sapere se va o no sempre per il nostro problema ¬Ø_(„ÉÑ)_/¬Ø
- adesso non va pi√π questo comando curl -X POST "https://backend-service-hclc243hba-ew.a.run.app/anonymize"   -H "Authorization: Bearer eyJhbGciO...[insomma tutto il token firebase]"   -F "file=@/c/Users/valen/OneDrive/Desktop/gruppo-5/utility/AgeGenderZipCodeDisease.csv"   -F "algorithm=k-anonymity"   -F "parameter=3" [d√† 401 unauthorized] e non so se non √® mai andato e sono scema io oppure se per motivi a me ignoti ora non va anche se non ho cambiato impostazioni di auth

23/06/25 - google storage
- ho implementato google storage, anche qui non so se √® tutto ok o c'√® qualche errore, per adesso non errori
- ho implementato i google secrets per alcune key sensibili, da passare a dani il file secret_variables.tfvar non versionato
- ho aggiunto lo "switch" tra modalit√† locale e GCP nella rotta anonymize.py, necessaria per disinguire lo sviluppo locale con GCP. Quindi bisogna ricordarsi di modificare quella variabile quando si cambia modalit√†
- non c'√® pi√π bisogno di commentare/scommentare la riga BASE_URL nell'HomePage.jsx  perch√® adesso lo switch tra locale e GCP √® fatto in maniera automatica